# cs230
Operating Platforms - Mock Software Design Document

Dustin Logan
04/27/2025
CS230 Operating Platforms

This class was an analysis of building software that works on all the different interfaces that an end user might experience it on.





Draw It or Lose It - Software Design Documentation

Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
The Gaming Room requested an outline for expanding their Android game, Draw It or Lose It, into a web-based application that could run across multiple platforms. My work focused on outlining a hypothetical software design that addressed scalability, memory efficiency, distributed systems, and security needs for this expansion.

What did you do particularly well in developing this documentation?
I feel that I clearly organized the design by applying object-oriented principles like inheritance and modularity. I also made strong recommendations about server platforms, storage management, and security practices that would support the projectâ€™s hypothetical goals.

What about the process of working through the design document did you find helpful when developing the code?
One of the challenges was thinking through real-world system requirements without actually building or testing a working program. It required focusing on theory and best practices instead of relying on trial and error, which made me think more carefully about infrastructure and dependencies from the beginning.

If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
If I were to improve the design document, I would add more visual elements like architecture diagrams or sequence diagrams to better illustrate how the different components would interact.

How did you interpret the user's needs and implement them into your software design? Why is it so important to consider the user's needs when designing?
I approached the design by thinking about what players and administrators would expect from a real web-based game: reliable access, quick performance, and strong security. Keeping user needs central to the design process made it easier to prioritize certain features and system choices.

How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
My strategies centered around building a scalable, secure foundation using modular design, Singleton patterns for memory control, and distributed networking techniques. Even though it was a hypothetical design, I tried to follow realistic software architecture principles that could support a live application in the future.
